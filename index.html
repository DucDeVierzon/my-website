<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="theme-color" content="#0b1020">
    <title>Sky Hopper</title>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        background: radial-gradient(circle at top, #18254d 0%, #0b1020 60%, #06080f 100%);
        color: #f4f7ff;
        height: 100vh;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      canvas {
        width: min(92vw, 480px);
        height: min(92vh, 820px);
        border-radius: 24px;
        background: linear-gradient(180deg, #b7d9ff 0%, #e9f7ff 65%, #c8f0ff 100%);
        box-shadow: 0 28px 60px rgba(0, 0, 0, 0.45);
        touch-action: none;
      }

      .hud {
        position: absolute;
        top: env(safe-area-inset-top, 12px);
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        pointer-events: none;
        text-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
      }

      .hud h1 {
        font-size: clamp(1.2rem, 2vw, 1.6rem);
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .hud p {
        margin-top: 0.25rem;
        font-size: 0.9rem;
        opacity: 0.9;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        gap: 0.8rem;
        padding: 1.5rem;
        background: rgba(7, 12, 25, 0.5);
        backdrop-filter: blur(6px);
      }

      .overlay h2 {
        font-size: 2rem;
      }

      .overlay p {
        max-width: 360px;
        line-height: 1.5;
        font-size: 1rem;
      }

      .cta {
        margin-top: 0.6rem;
        padding: 0.75rem 1.5rem;
        border-radius: 999px;
        border: none;
        background: #ffe66d;
        color: #0b1020;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
      }

      .touch-zone {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 50%;
        z-index: 2;
      }

      .touch-zone.left {
        left: 0;
      }

      .touch-zone.right {
        right: 0;
      }

      .score {
        position: absolute;
        right: 18px;
        top: calc(env(safe-area-inset-top, 12px) + 8px);
        background: rgba(11, 16, 32, 0.6);
        padding: 0.4rem 0.75rem;
        border-radius: 999px;
        font-weight: 600;
        font-size: 0.9rem;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="hud">
      <h1>Sky Hopper</h1>
      <p>Tap left/right or use arrow keys. Bounce higher than the clouds.</p>
    </div>
    <div class="score" id="score">Score 0</div>
    <canvas id="game" width="360" height="640" aria-label="Sky Hopper game"></canvas>
    <div class="touch-zone left" aria-hidden="true"></div>
    <div class="touch-zone right" aria-hidden="true"></div>

    <div class="overlay" id="overlay">
      <h2>Ready to hop?</h2>
      <p>
        Rise through floating platforms and keep the sky under your feet. The higher you
        go, the faster the wind pushes.
      </p>
      <button class="cta" id="startButton">Start bouncing</button>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const overlay = document.getElementById("overlay");
      const scoreEl = document.getElementById("score");

      const state = {
        running: false,
        score: 0,
        maxHeight: 0,
        player: {
          x: canvas.width / 2,
          y: canvas.height * 0.65,
          radius: 16,
          vx: 0,
          vy: -12,
        },
        gravity: 0.45,
        wind: 0,
        platforms: [],
        keys: { left: false, right: false },
      };

      const platformConfig = {
        width: 80,
        height: 12,
        gap: 90,
        count: 9,
      };

      const resetGame = () => {
        state.score = 0;
        state.maxHeight = 0;
        state.wind = 0;
        state.player.x = canvas.width / 2;
        state.player.y = canvas.height * 0.65;
        state.player.vx = 0;
        state.player.vy = -12;
        state.platforms = [];
        let y = canvas.height - 40;
        for (let i = 0; i < platformConfig.count; i += 1) {
          state.platforms.push({
            x: Math.random() * (canvas.width - platformConfig.width),
            y,
            wobble: Math.random() * Math.PI * 2,
          });
          y -= platformConfig.gap;
        }
      };

      const resizeCanvas = () => {
        const scale = Math.min(window.innerWidth * 0.92 / 360, window.innerHeight * 0.92 / 640, 1.4);
        canvas.style.transform = `scale(${scale})`;
      };

      const drawBackground = () => {
        ctx.fillStyle = "#b7d9ff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const cloudColors = ["rgba(255,255,255,0.9)", "rgba(245,252,255,0.7)"];
        for (let i = 0; i < 6; i += 1) {
          const y = (i * 120 + (state.maxHeight * 0.2)) % canvas.height;
          ctx.fillStyle = cloudColors[i % cloudColors.length];
          ctx.beginPath();
          ctx.ellipse(60 + i * 40, canvas.height - y, 48, 18, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      };

      const drawPlayer = () => {
        const { x, y, radius } = state.player;
        ctx.fillStyle = "#ff7b7b";
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#2a1e2a";
        ctx.beginPath();
        ctx.arc(x - 5, y - 4, 3, 0, Math.PI * 2);
        ctx.arc(x + 5, y - 4, 3, 0, Math.PI * 2);
        ctx.fill();
      };

      const drawPlatforms = () => {
        ctx.fillStyle = "#3bcf9b";
        state.platforms.forEach((platform) => {
          ctx.beginPath();
          ctx.roundRect(platform.x, platform.y, platformConfig.width, platformConfig.height, 10);
          ctx.fill();
        });
      };

      const updatePlayer = () => {
        const input = state.keys.left ? -1 : state.keys.right ? 1 : 0;
        const targetVx = input * 4 + state.wind;
        state.player.vx += (targetVx - state.player.vx) * 0.15;
        state.player.x += state.player.vx;
        state.player.vy += state.gravity;
        state.player.y += state.player.vy;

        if (state.player.x < -state.player.radius) {
          state.player.x = canvas.width + state.player.radius;
        }
        if (state.player.x > canvas.width + state.player.radius) {
          state.player.x = -state.player.radius;
        }
      };

      const updatePlatforms = () => {
        state.platforms.forEach((platform) => {
          platform.wobble += 0.02;
          platform.x += Math.sin(platform.wobble) * 0.2;
        });
      };

      const handleCollisions = () => {
        if (state.player.vy <= 0) return;
        state.platforms.forEach((platform) => {
          const withinX =
            state.player.x + state.player.radius > platform.x &&
            state.player.x - state.player.radius < platform.x + platformConfig.width;
          const withinY =
            state.player.y + state.player.radius > platform.y &&
            state.player.y + state.player.radius < platform.y + platformConfig.height + 10;
          if (withinX && withinY) {
            state.player.vy = -11 - Math.min(state.score / 200, 6);
          }
        });
      };

      const scrollWorld = () => {
        if (state.player.y < canvas.height * 0.35) {
          const delta = canvas.height * 0.35 - state.player.y;
          state.player.y = canvas.height * 0.35;
          state.platforms.forEach((platform) => {
            platform.y += delta;
          });
          state.maxHeight += delta;
        }

        const top = Math.min(...state.platforms.map((platform) => platform.y));
        if (top > -20) {
          state.platforms.push({
            x: Math.random() * (canvas.width - platformConfig.width),
            y: top - platformConfig.gap,
            wobble: Math.random() * Math.PI * 2,
          });
        }

        state.platforms = state.platforms.filter((platform) => platform.y < canvas.height + 40);
      };

      const updateScore = () => {
        state.score = Math.max(state.score, Math.floor(state.maxHeight / 10));
        state.wind = Math.sin(state.score / 50) * 1.2;
        scoreEl.textContent = `Score ${state.score}`;
      };

      const checkGameOver = () => {
        if (state.player.y - state.player.radius > canvas.height) {
          state.running = false;
          overlay.classList.remove("hidden");
          overlay.querySelector("h2").textContent = "Out of the clouds!";
          overlay.querySelector("p").textContent = `You reached a height of ${state.score} meters. Tap to try again.`;
          overlay.querySelector("button").textContent = "Hop again";
          overlay.style.display = "flex";
        }
      };

      const gameLoop = () => {
        if (!state.running) return;
        drawBackground();
        updatePlayer();
        updatePlatforms();
        handleCollisions();
        scrollWorld();
        updateScore();
        drawPlatforms();
        drawPlayer();
        checkGameOver();
        requestAnimationFrame(gameLoop);
      };

      const startGame = () => {
        resetGame();
        overlay.style.display = "none";
        state.running = true;
        gameLoop();
      };

      document.getElementById("startButton").addEventListener("click", startGame);
      overlay.addEventListener("click", () => {
        if (!state.running) startGame();
      });

      const handleKey = (event, isDown) => {
        if (event.key === "ArrowLeft" || event.key === "a") {
          state.keys.left = isDown;
        }
        if (event.key === "ArrowRight" || event.key === "d") {
          state.keys.right = isDown;
        }
      };

      window.addEventListener("keydown", (event) => handleKey(event, true));
      window.addEventListener("keyup", (event) => handleKey(event, false));

      const leftZone = document.querySelector(".touch-zone.left");
      const rightZone = document.querySelector(".touch-zone.right");

      const bindTouch = (zone, direction) => {
        const start = (event) => {
          event.preventDefault();
          state.keys[direction] = true;
        };
        const end = () => {
          state.keys[direction] = false;
        };
        zone.addEventListener("touchstart", start, { passive: false });
        zone.addEventListener("touchend", end);
        zone.addEventListener("touchcancel", end);
        zone.addEventListener("pointerdown", start);
        zone.addEventListener("pointerup", end);
        zone.addEventListener("pointerleave", end);
      };

      bindTouch(leftZone, "left");
      bindTouch(rightZone, "right");
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
    </script>
  </body>
</html>
